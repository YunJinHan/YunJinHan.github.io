<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>JinHan's Blog</title>
		<description>Software Developer</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Angular Service1</title>
				<description>&lt;h1 id=&quot;angular2-service&quot;&gt;Angular2 Service&lt;/h1&gt;
&lt;p&gt;서비스는 &lt;strong&gt;@Injectable&lt;/strong&gt; 장식자 ( = 주입 가능한 클래스라는 뜻 ) 를 추가한 클래스 이다.&lt;br /&gt;&lt;br /&gt;
@Injectable 을 생략한다고 해서 의존성 주입에 문제가 생기는 것은 아니지만, 생략하였을때 일반 클래스라 오인할 수 있기 때문에 반드시 추가해야 한다.&lt;/p&gt;

&lt;pre&gt;
import { Injectable } from '@angular/core';

@Injectable()
export class HelloService {
  sayHello(){
    return &quot;Hello 서비스!&quot;;
  }
  constructor() {}
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; hello.service.ts / HelloService 라는 서비스 생성&lt;/p&gt;

&lt;pre&gt;
import { Component } from '@angular/core';
import { HelloService } from './hello.service';

@Component({
  selector: 'hello',
  template: ``,
  providers: [HelloService]
  // -&amp;gt; providers 로 서비스 선언한다.
})
export class HelloComponent {
  welcome: string;

  constructor(helloService: HelloService) {
    this.welcome = helloService.sayHello();
  } // -&amp;gt; 생성자에서 서비스 선언 후 사용 (추천)
  
  constructor() {
  	let Hello = new HelloService();
  	this.welcome = Hello.sayHello();
  } // -&amp;gt; 생성자에서 서비스 선언하지 않고 사용 (비추천 : 새로운 변수 생성 / 메모리 사용)
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; hello.component.ts&lt;br /&gt;providers 에 사용할 서비스를 컴포넌트에서 HelloService 를 불러와 생성자에서 선언 후 사용.&lt;br /&gt;&lt;br /&gt;
생성자에서 선언하지 않고 &lt;strong&gt;&lt;em&gt;let Hello = new HelloSerivce();&lt;/em&gt;&lt;/strong&gt; 로 사용가능.&lt;/p&gt;

&lt;h3 id=&quot;--객체지향-서비스&quot;&gt;- 객체지향 서비스&lt;/h3&gt;
&lt;p&gt;크게 부모 / 자식 클래스가 있고 자식 클래스에는 공통 메서드가 정의돼 있기 떄문에 공통 메서드를 제어할 수 있는 인터페이스를 정의한다.&lt;/p&gt;

&lt;pre&gt;
import { Injectable } from '@angular/core';

@Injectable()
export class Parent {

  getName(){    
    return &quot;Parent 서비스!&quot;;
  }
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; parent.service.ts / 부모 서비스&lt;/p&gt;

&lt;pre&gt;
import { Injectable } from '@angular/core';
import { Parent } from './parent.service';

export interface Child {
  getData();
}

@Injectable()
export class FirstChild implements Child {

  constructor(public parent: Parent) { }
  // -&amp;gt; Child 인터페이스만 사용하였기 떄문에 부모는 생성자에 선언하여 사용하여야 한다.
  
  getData() {
    return [
      { Child: 'FirstChild 서비스' },
      { parent: this.parent.getName() }
    ];
  }
}

@Injectable()
export class SecondChild extends Parent implements Child {
  getData() {
    return [
      { Child: 'SecondChild 서비스' },
      { parent: super.getName() }
      // -&amp;gt; 부모를 상속하였기 때문에 super 로써 사용가능하다.
    ];
  }
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; child.service.ts / 자식 서비스&lt;br /&gt;&lt;br /&gt;
위의 예시처럼 First / Second 로 Parent 를 사용가능하지만&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;SecondChild 에서는 super 를 통하여 호출하기 때문에 다른 컴포넌트나 객체로 부모의 데이터를 전달 할수 없으나 FirstChild 에서 처럼 생성자에서 부모를 선언 후 사용한다면 전달이 가능하기 떄문에 extends 를 사용하는것 대신에 생성자에서 부모를 선언하여 사용하는 것이 바람직하다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
import { Component } from '@angular/core';
import { Parent } from './parent.service';
import { FirstChild, SecondChild } from './child.service';

@Component({
  selector: 'oop-cmp',
  template: `
      생성자 주입방식&amp;lt; br&amp;gt;
      &amp;lt; br&amp;gt;
      상속방식&amp;lt; br&amp;gt;
      `,
  providers: [Parent, FirstChild, SecondChild]
})
export class OopComponent {
  firstChildData;
  secondChildData;
  
  constructor(firstChild: FirstChild, secondChild: SecondChild) {
    this.firstChildData = firstChild.getData();
    this.secondChildData = secondChild.getData();
  }
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; oop.component.ts / 컴포넌트&lt;/p&gt;

&lt;h3 id=&quot;--목-객체-서비스&quot;&gt;- 목 객체 서비스&lt;/h3&gt;
&lt;p&gt;서버 의존성 없이 데이터를 제공하기 위해 테스트 데이터를 정의한 객체이다.&lt;br /&gt;&lt;br /&gt;
목 객체를 사용하는 이유는 개발 과정에서 서버 의존성과 같은 외부 의존성을 제거함으로써 테스트를 가능하게 하기 위함이다.&lt;/p&gt;

&lt;pre&gt;
export class User {
  name: string;  
  id : string;
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; user.ts / User 데이터 객체&lt;/p&gt;

&lt;pre&gt;
import { User } from './user';

export var USER: User[] = [
  {name: '유비',id:'1'},
  {name: '관우',id:'2'},
  {name: '장비',id:'3'}  
];
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; mock-user.ts / 테스트 데이터 객체 USER 생성&lt;/p&gt;

&lt;pre&gt;
import { Injectable } from '@angular/core';
import { USER } from './mock-user';

export interface DataServiceStructure{
  getUser();
}

@Injectable()
export class MockService implements DataServiceStructure{
  constructor() {}
  getUser(){
    return USER;
  }
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; mock.service.ts / 목 서비스 생성 : 테스트 데이터 USER 를 리턴하는 서비스 생성&lt;/p&gt;

&lt;pre&gt;
import { Component, OnInit } from '@angular/core';
import { MockService } from './mock.service';
import { User } from './user';

@Component({
  selector: 'mock',
   template: `
    &amp;lt; b&amp;gt;이름 출력&amp;lt; /b&amp;gt;
    &amp;lt; div *ngFor=&quot;let o of listUser&quot;&amp;gt;
         | 
    &amp;lt; /div&amp;gt;`,
  providers: [MockService]
})
export class MockComponent {

  listUser: User[];
  // -&amp;gt; listUser 라는 리스트를 해당 User 라는 데이터 타입의 객체로 사용한다.

  constructor(private userService: MockService) {
    this.listUser = userService.getUser();
    // -&amp;gt; MockService 를 선언하여 해당 USER 데이터를 불러와 저장함. 
  }
}
&lt;/pre&gt;

&lt;p&gt;===&amp;gt; mock-component.ts / 해당 서비스와 데이터 타입 객체를 불러와 사용&lt;/p&gt;
</description>
				<pubDate>Sun, 30 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/Angular2-Service</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/Angular2-Service</guid>
			</item>
		
			<item>
				<title>Angular Component2</title>
				<description>&lt;h1 id=&quot;angular-component2&quot;&gt;Angular Component2&lt;/h1&gt;
&lt;p&gt;Input 을 이용한 값 전달&lt;br /&gt;
—–&lt;/p&gt;
&lt;h3 id=&quot;--input-장식자를-이용한-값-받기&quot;&gt;- input 장식자를 이용한 값 받기&lt;/h3&gt;
&lt;p&gt;@input 장식자는 외부에서 전달된 값을 받기 위해 사용된다.&lt;br /&gt;( 부모에서 자식으로 값을 전달할 때 많이 사용됨 )&lt;/p&gt;

&lt;pre&gt;
import { Component } from '@angular/core';
@Component({
	selector: 'parent-to-child-input',
	template: `&amp;lt; div&amp;gt;부모
	&amp;lt; child-input [name1]=&quot;fruit1&quot; [name2]=&quot;fruit2()&quot; [name3]=&quot;fruit3&quot;
	  [name4]=&quot;1+1&quot; [name5]=&quot;fruit5&quot; [name6]=&quot;fruit6&quot;&amp;gt;&amp;lt; /child-input&amp;gt;
	&amp;lt; /div&amp;gt;`,
	styles: [`div{border : 2px soild #666; width:90%; height:50%}`]
})

export class ParentToChildInputComponent {
	fruit1 = &quot;사과&quot;;
	fruit2() {
		return &quot;배&quot;;
	}
	fruit3 = ['딸기','포도','참외'];
	static fruit5 = &quot;수박&quot;;
	get fruit6() {
		return ParentToChildInputComponent.fruit5;
	}
}
&lt;/pre&gt;
&lt;p&gt;==&amp;gt; 부모 컴포넌트 ( 자식에게 값을 전달함 )&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;정적변수 static ( fruit5 ) 은 자식 컴포넌트로 곧바로 전달할 수 없다.&lt;br /&gt;&lt;br /&gt;
곧바로 전달하려면 getter 메소드 ( fruit6 ) 를 사용해야 한다&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
import { Component, Input } from '@angular/core';
@Component({
	selector: 'child-input',
	template: `&amp;lt; div&amp;gt;
	자식&amp;lt; br&amp;gt;
	name1 : &amp;lt; br&amp;gt;
	name2 : &amp;lt; br&amp;gt;
	name3 : &amp;lt; span *ngFor=&quot;let i of name3&quot;&amp;gt;&amp;lt; /span&amp;gt;&amp;lt; br&amp;gt;
	name4 : &amp;lt; br&amp;gt;
	name5 : &amp;lt; br&amp;gt;
	name6 : &amp;lt; br&amp;gt;
	&amp;lt; /div&amp;gt;`,
	styles: [`div{border : 2px soild #666; width:90%; height:50%}`]
})

export class ChildInputComponent {
	@Input() name1 : string;
	@Input() name2 : string;
	@Input() name3 : string[];
	@Input() name4 : number;
	@Input() name5 : string;
	@Input() name6 : string;
}
&lt;/pre&gt;
&lt;p&gt;===&amp;gt; 자식 컴포넌트 ( 부모로부터 값을 전달받음 )&lt;br /&gt;&lt;br /&gt;
&amp;lt; 출력 결과 &amp;gt;&lt;/p&gt;
&lt;pre&gt;
부모
자식
name1 : 사과
name2 : 배
name3 : 딸기 포도 참외
name4 : 2
name5 :
name6 : 수박
&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;--input-속성을-이용한-값-받기&quot;&gt;- input 속성을 이용한 값 받기&lt;/h3&gt;
&lt;p&gt;Component 장식자 설정의 inputs 속성을 통하여 값을 주고 받는 것이 가능하다.&lt;/p&gt;

&lt;pre&gt;
import { Component } from '@angular/core';
@Component({
	selector: 'app-parent-to-child-inputs',
	template: `&amp;lt; div&amp;gt;부모
	&amp;lt; child-inputs [name1]=&quot;name1&quot; [name2]=&quot;name2&quot;&amp;gt;
	&amp;lt; /child-input&amp;gt;&amp;lt; /div&amp;gt;`,
	styles: [`div{border : 2px soild #666; width:90%; height:50%}`]
})

export class ParentToChildInputsComponent {
	name1 = &quot;사과&quot;;
	name2 = &quot;바나나&quot;;
}
&lt;/pre&gt;
&lt;p&gt;===&amp;gt; 부모 컴포넌트&lt;/p&gt;

&lt;pre&gt;
import { Component, Input } from '@angular/core';
@Component({
	selector: 'child-inputs',
	template: `&amp;lt; div&amp;gt;자식&amp;lt; br&amp;gt;
	input 값 : ,  &amp;lt; /div&amp;gt;`,
	styles: [`div{border : 2px soild #666; width:90%; height:50%}`],
	inputs: ['name1','name2']
})

export class ChildInputsComponent {
	name1 : string;
	name2 : string;
}
&lt;/pre&gt;
&lt;p&gt;===&amp;gt; 자식 컴포넌트&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;eventemitter-를-이용한-값-전달&quot;&gt;EventEmitter 를 이용한 값 전달&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;부모 컴포넌트로 값을 전달하려면 @Output 장식자로 선언한 변수를 EvenEmitter 로 초기화 한다.&lt;br /&gt;&lt;br /&gt;
그리고 부모에게 보낼 시점이 되면 emit() 메서드를 통하여 부모로 이벤트를 전달한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
import { Component, EventEmitter, Output } from '@angular/core';
@Component({
	selector: 'child',
	template: `&amp;lt; div&amp;gt;자식
	&amp;lt; button (click)=&quot;updateParent(active)&quot;&amp;gt;부모에게 이벤트보내기
	&amp;lt; /button&amp;gt;&amp;lt; /div&amp;gt;`,
	styles: [`div{border : 2px soild #666; width:90%; height:50%}`]
})

export class ChildComponent {
	active = false;
	@Output() outputProperty = new EventEmitter&amp;lt; boolean&amp;gt;();
	
	updateParent(active: boolean) {
		this.active = !active;
		this.outputProperty.emit(this.active);
	}
}
&lt;/pre&gt;
&lt;p&gt;===&amp;gt; 자식 컴포넌트&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;EventEmiiter 객체의 자료형은 boolean 으로 선언되어있으며 받는 측에서도 동일한 자료형으로 받아야 하며 이벤트가 발생하면 emit() 을 통해 전달된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
import { Component } from '@angular/core';
@Component({
	selector: 'app-root',
	template: `&amp;lt; div&amp;gt;부모
				클릭수 : &amp;lt; br&amp;gt;
				자식상태 : &amp;lt; br&amp;gt;
				&amp;lt; child (outputProperty)=&quot;outputEvent($event)&quot;&amp;gt;
				&amp;lt; /child&amp;gt;&amp;lt; /div&amp;gt;`,
	styles: [`div{border : 2px soild #666; width:90%; height:50%}`]
})

export class ChildToParentComponent {
	cntClick = 0;
	active = false;
	
	outputProperty(active: boolean) {
		this.cntClick ++;
		this.active = active; ( 자식으로부터 받은 active 값 )
	}
}
&lt;/pre&gt;
&lt;p&gt;===&amp;gt; 부모 컴포넌트&lt;/p&gt;
</description>
				<pubDate>Sat, 29 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/Angular2-Component2</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/Angular2-Component2</guid>
			</item>
		
			<item>
				<title>UP Development - 2.Elaboration</title>
				<description>&lt;h1 id=&quot;up-development---2elaboration&quot;&gt;UP Development - 2.Elaboration&lt;/h1&gt;
&lt;p&gt;Build the core architecture, resolve the high-risk elements, define most requirements, and estimate overall schedule and resources&lt;br /&gt;
—–&lt;/p&gt;

&lt;h3 id=&quot;--elaboration-is-the-initial-series-of-iterations-during-which--the-follwing-content&quot;&gt;- Elaboration is the initial series of iterations during which : the follwing content&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The majority of requirements are discovered and stabilized
    &lt;ul&gt;
      &lt;li&gt;70 ~ 80 % 의 requirements 는 수용되어야 한다.&lt;/li&gt;
      &lt;li&gt;wirte most of the Use Cases and other requirements in detail&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The marjor &lt;strong&gt;Risk&lt;/strong&gt; are mitigated or retired. ( &lt;strong&gt;기술 / 비지니스 관점에서 대다수의 위험성은 해결되어야 함&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;The core &lt;strong&gt;Architectural&lt;/strong&gt; elements are implemented and proven. ( &lt;strong&gt;System 의 중요한 architectural 는 어느 정도 구현되고 안정되어 있어야 한다&lt;/strong&gt; )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--elaboration-phase&quot;&gt;- Elaboration Phase&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Elaboration consists of between two and four iterations
    &lt;ul&gt;
      &lt;li&gt;each iteration is recommended to between two and six weeks, unless the term size is massive&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Each iteration is timeboxed, meaning its end date is fixed&lt;/li&gt;
  &lt;li&gt;At the end of each iteration, stable and tested &lt;strong&gt;Production-Quality&lt;/strong&gt; portions of the final system must be released&lt;br /&gt;( 각각 iteration 마지막 부분에서, Final system 의  안정적이고 검증된 Production-Quality 부분은 반드시 해결되야 한다. )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--what-is-architecturally-singificant-in-elaboratoin&quot;&gt;- What is Architecturally Singificant in Elaboratoin?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Employing &lt;strong&gt;Wide and Shallow&lt;/strong&gt; design and implementation.
    &lt;ul&gt;
      &lt;li&gt;Implementing simplified and End to End scenarios that force design, implementation, and test across major components.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Integrating existing componets&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--planning-the-next-iteration&quot;&gt;- Planning the Next Iteration&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Organize requirements and iterations by &lt;strong&gt;Risk, Coverage, and Criticality&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Risk&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Includes Both technical complexity and other factors, such as uncertainty of effort or usablity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coverage&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Implies that all major parts of the system are at least touched on in early iterations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Criticality&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Refers to functions of high business value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==&amp;gt;  &lt;strong&gt;3가지에 Weight 를 부여하여 높은 순서대로 먼저 수행한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;--artifacts-that-may-start-in-elaboration&quot;&gt;- Artifacts that May Start in Elaboration&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Domain Model&lt;/strong&gt; : This is a visualization of the domain concepts; it is similar to a static information model of the domain entities ( static / dynamic model )&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Design Model&lt;/strong&gt; : This is the set of diagrams that describe the logical design, This includes software class diagram, object interaction diagram, packgae diagrams, and so forth&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ArtifactsInElaboration.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;drawing-system-sequence-diagrams&quot;&gt;Drawing System Sequence Diagrams&lt;/h2&gt;
&lt;h4 id=&quot;--objectives&quot;&gt;- Objectives&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Identify system events and system operations.&lt;/li&gt;
  &lt;li&gt;Create system sequence diagram for Use Cases.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--ssd--system-sequence-diagrams-&quot;&gt;- SSD ( System Sequence Diagrams )&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;System behavior&lt;/strong&gt; is a description of &lt;strong&gt;What&lt;/strong&gt; a system does, without explaning &lt;strong&gt;How&lt;/strong&gt; it does it&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;System Sequence Diagram&lt;/strong&gt; captures the system behavior, for a particular scenario of a Use Case, by illustrating the events that external actors generate to SuD, their order, and inter-system events
    &lt;ul&gt;
      &lt;li&gt;It allows us to treat the system as a &lt;strong&gt;BLack Box&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;System Sequence Diagram emphasizes those events that &lt;strong&gt;Cross&lt;/strong&gt; the system boundary from actors to systems&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;System Sequence Diagram should be done for the main success scenario of the Use Case, and frequent or complex alternative scenarios&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--system-events--system-operations&quot;&gt;- System Events &amp;amp; System Operations&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;System event&lt;/strong&gt; is an external event generated by an external actor to a system —&amp;gt; &lt;strong&gt;Stimulus&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;System operation&lt;/strong&gt; is an operation of the system that executes in response to a system event —&amp;gt; &lt;strong&gt;Response&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The set of all required system operations is determined by identifying the system evnets. The system events are derived from Use Case&lt;br /&gt;( &lt;strong&gt;System 외부에서  Event 가 주어졌을때 해당 Event 에 대한 System 이 취한 동작&lt;/strong&gt; )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/SysESysO.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;System Sequence Diagram shows system events for a scenario of a Use Case, therefore it is generated from inspection of a Use Case&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--naming-system-events--operations&quot;&gt;- Naming System Events / Operations&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;System events and theri associated events should be &lt;strong&gt;Expressed at the (highest) level of Intent&lt;/strong&gt; rather than in terms of physical input medium or interface widget&lt;/li&gt;
  &lt;li&gt;Usually start with a “Verb” like add, enter, make …&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/NamingSystem.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--showing-use-case-text&quot;&gt;- Showing Use Case Text&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;The text provides the details and context&lt;br /&gt;the diagram visually summarizes the interaction&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;--recording-system-operations--class-icon&quot;&gt;- Recording System Operations &amp;amp; Class Icon&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UML class icon provides a compartment to record operations for a type&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/RecordingSystemOperation.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ClassIcon.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;--how-to-make-system-sequence-diagram&quot;&gt;- How To Make System Sequence Diagram&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Draw a line representing the system as a black box&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Identify each actor that directly operates on the system&lt;br /&gt;Draw a line for each such actor&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;From the Use Case main success scenario text,&lt;br /&gt;&lt;strong&gt;Identify the system ( External ) events that each actor generates. illustrate them on the diagram&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Optionally, include the Use Case text to the left of the diagram&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Thu, 20 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/UP-Development-2.-Elaboration</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/UP-Development-2.-Elaboration</guid>
			</item>
		
			<item>
				<title>UP Development - 1.Inception (Cont'd) 2</title>
				<description>&lt;h1 id=&quot;up-development---1inception-contd&quot;&gt;UP Development - 1.Inception (Cont’d)&lt;/h1&gt;
&lt;h3 id=&quot;--main-success-scenario&quot;&gt;- Main Success Scenario&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;It describes typical success path that satisfies the interests of the stakeholders&lt;/li&gt;
  &lt;li&gt;It records three kinds of actions
    &lt;ul&gt;
      &lt;li&gt;interaction between actors&lt;/li&gt;
      &lt;li&gt;validation&lt;/li&gt;
      &lt;li&gt;state change by the system&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step one of UseCase normally indicates the trigger event that strats the UseCase&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Defer all conditional and branching to the Extensions section&lt;/strong&gt; ( 모든 확장부분의 분기와 조건은 미룬다 )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--extensions--or-alternative-flows-&quot;&gt;- Extensions ( or Alternative Flows )&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Extensions indicate all the other scenarios or branches, both success and failure&lt;/li&gt;
  &lt;li&gt;Extension has two parts &lt;strong&gt;Condition&lt;/strong&gt; and &lt;strong&gt;The Handing&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Write the condition as something that can be detected by the system or an actor&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
Example )
Extensions:
3a. Invalid identifier:
&amp;nbsp;&amp;nbsp;1.System signals error and rejects entry.
3b. There are multiple of same item category and tracking unique item identity not important (e.g., 5 packages of veggie-burgers):
&amp;nbsp;&amp;nbsp;1.Cashier can enter item category identifier and the quantity. 
3-6a. Customer asks Cahier to remove an item from the purchase:
&amp;nbsp;&amp;nbsp;1.Cashier enters the item identifier for removal from the sale.
&amp;nbsp;&amp;nbsp;2.System displays updated running total.
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;At the end of extension handing, by default the scenario merges back with the main success scenario, unless the extension indicates otherwise ( such as by halting the system )&lt;/li&gt;
  &lt;li&gt;If a particular extension is quite complex, a separate use case may be written&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
Example )
7b. Paying by credit:
&amp;nbsp;&amp;nbsp;1.Customer enters their credit card information.
&amp;nbsp;&amp;nbsp;2.System requests payment validation from external Payment Authorization Serive system.
&amp;nbsp;&amp;nbsp;2a. System detects failure to collaborate with external system.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.System signals error to Cashier.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.Cashier asks Customer for alternate payment. 3. ...
*a. At any time, System crashes:
In order to support recovery and correct accounting, ensure all transaction sensative state and events can be recovered at any step in the scenario.
&amp;nbsp;&amp;nbsp;1.Cahier restarts the System, log in, and requests recovery of prior state.
&amp;nbsp;&amp;nbsp;2.System reconstructs prior state.
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/scenarioLevel.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;–&amp;gt; &lt;strong&gt;논리적으로 계속해서 자기 자신을 하나의 Action Step 으로 가진 Use Case 를 만들수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;--special-requirement&quot;&gt;- Special Requirement&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Non-functional requirements, quality attributes, and constraints which relates specifically to a use case are recorded with the use case&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
Example )
Special Requirements:
-Touch screen UI on a large flat panel monitor. Text must be visible from 1 meter. 
-Credit authorization response within 30 seconds within 90% of time.
-Language internationalization on the text displayed.
-Pluggable business rules to be insertable at steps 2 and 6.
&lt;/pre&gt;

&lt;h3 id=&quot;--technology-and-data-variations-list&quot;&gt;- Technology and Data Variations List&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;This section records technical variations in how something must be done, but not what&lt;/li&gt;
  &lt;li&gt;This section also records variations in data scheme&lt;/li&gt;
  &lt;li&gt;This section should not contain multiple steps to express varying behavior for different cases. If that is necessary, say it in the Extensions section&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
Example )
Technology and Data Variations List:
3a. Item identifier entered by laser scanner or keyboard.
3b. Item identifier may be any UPC, EAN, JAN, or SKU coding scheme.
7a. Credit account information entered by card reader or keyboard.
7b. Credit payment signature captured on paper receipt. But within two years, we pre-dict many customers will want digital signature capture.
&lt;/pre&gt;

&lt;h3 id=&quot;--key-four-concepts-that-apply-to-every-sentence-in-usecaese-and-to-the-usecase-as-a-whole&quot;&gt;- Key Four Concepts that apply to every sentence in UseCaese and to the UseCase as a whole&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Level : Why do we want this goal? ( 어느 정도의 Goal Level 이냐 )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Scope : Which system boundary do we mean? ( System 의 Boundary 가 어디까지냐 )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Detail : Do we describe intent, or action detail?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Primary Actor : Who has the goal?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--what-is-a-useful-level-to-express-use-cases-for-application-requirements-analysis--어플리케이션-요구사항-분석을-usecase로-표현하기-위해-어떤-레벨이-효과적인가-&quot;&gt;- What is a useful level to express use cases for application requirements analysis? ( 어플리케이션 요구사항 분석을 UseCase로 표현하기 위해 어떤 레벨이 효과적인가? )&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Guideline : The &lt;strong&gt;EBP(OR User Goals ) Use Case&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EBP : Elementary Business Processes&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--common-mistake-with-use-cases&quot;&gt;- Common Mistake with Use Cases&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Use Case is a relatively large end to end Description that typically indcludes many steps or transactions&lt;/li&gt;
  &lt;li&gt;It is normally an individual step or activity in a process&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--every-sentence-at-every-level-is-a-goal-use-cases-are-one-sentence-style-repeated&quot;&gt;- Every Sentence at every level is a Goal. Use Cases are one sentence style repeated&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/goal.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HOW : Goal Level 낮아짐&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;Why : Goal Level 높아짐&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;--primary-actors-and-goals-at-different-boundaries&quot;&gt;- Primary Actors and Goals at different Boundaries&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/primaryActors.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;basic-procedure&quot;&gt;Basic Procedure&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Choose the system boundary&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Identify the primary actors&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;For each primary actor, identify their user goals&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Define use cases that satisfy user goal; name them according to their goal&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;step-1--choosing-the-system-boundary&quot;&gt;Step 1 : Choosing the System Boundary&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Choosing the right system boundary helps to find what is outside, i.e., primary actors and supporting actors.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;step-23--finding-primary-actors-and-goals&quot;&gt;Step 2/3 : Finding Primary Actors and Goals&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;What computers, subsystems and people will drive our system?
    &lt;ul&gt;
      &lt;li&gt;An actor is anything with behavior.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;What does each actor need our system to do?
    &lt;ul&gt;
      &lt;li&gt;Each need shows up as a trigger to our system.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;A List of use cases, a sketch of the system
    &lt;ul&gt;
      &lt;li&gt;Short, fairly complete list of usable system function&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;reminder-questions-to-find-actors&quot;&gt;Reminder Questions to Find Actors&lt;/h5&gt;
&lt;p&gt;Primary actors and supporting actors are always external to SuD. To find actors, look for things in the categories of people, other software, hardware devices, data stores, or networks&lt;/p&gt;

&lt;h5 id=&quot;reminder-questions-to-find-goals&quot;&gt;Reminder Questions to Find Goals&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;In the UP, a use case is always started by a primary actor. But, it is sometimes useful to initiate use cases from inside the system&lt;/li&gt;
  &lt;li&gt;Actor-based
    &lt;ul&gt;
      &lt;li&gt;Identify the actors related to a system or organization&lt;/li&gt;
      &lt;li&gt;For each actor, identify the process they initiate or participate in.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Event-based
    &lt;ul&gt;
      &lt;li&gt;Identify the external events that a system must respond to.&lt;/li&gt;
      &lt;li&gt;Relate the events to actors and use cases.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/actorGoalList.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;ranking-use-cases&quot;&gt;Ranking Use Cases&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Use cases need to be ranked, and high ranking use cases need to be tackled early&lt;/li&gt;
  &lt;li&gt;Ranking criteria
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Significant impact on the core architectural design&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Risky, time-critical, or complex functions&lt;/li&gt;
      &lt;li&gt;Risky technology&lt;/li&gt;
      &lt;li&gt;Primary line of business process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;step-4--define-use-cases&quot;&gt;Step 4 : Define Use Cases&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;In general, define one EBP-level (or user goals) use case for each user goal&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;how-to-do-it&quot;&gt;How to do it&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;For each Use Case : Write the simple case - &lt;strong&gt;Goal Delivers&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The main success scenario, the happy day case. ( 각각의 UC 에 대해 정해야 함 )
        &lt;ul&gt;
          &lt;li&gt;Easiest to read and understand, Everything else is a complication on this.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Capture each actor’s intent and responsibility, from trigger to goal delivery
        &lt;ul&gt;
          &lt;li&gt;Say what information passes between them, Number each line&lt;br /&gt;&lt;br /&gt;RESULT : &lt;strong&gt;Readable description of system’s function&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Write failure conditions as extensions
    &lt;ul&gt;
      &lt;li&gt;Usually, each step can fail.&lt;/li&gt;
      &lt;li&gt;Note the failure condition separately, after the main&lt;br /&gt;
success scenario&lt;/li&gt;
      &lt;li&gt;RESULT : &lt;strong&gt;list of alternate scenarios&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Follow the failure till it ends or rejoins
    &lt;ul&gt;
      &lt;li&gt;Recoverable extensions rejoin main course.&lt;/li&gt;
      &lt;li&gt;Non-recoverable extensions fail directly.&lt;/li&gt;
      &lt;li&gt;Each scenario goes from trigger to completion&lt;/li&gt;
      &lt;li&gt;RESULT : &lt;strong&gt;Complete use case&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;essential-vs-concrete-use-cases&quot;&gt;Essential VS Concrete Use Cases&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Essential use cases are expanded use cases that are expressed in an ideal&lt;/strong&gt; ( 무엇을 할 것인가 )&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Concrete use cases concretely describes the process in terms of its real current design&lt;/strong&gt; ( 무엇을 어떻게 할 것인가 )&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;처음 Request 분석 : Essential ( Reusable )&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;나중 점점 진행 : Concrete 으로 진행 ( non Reusable )&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;use-case-diagram&quot;&gt;Use Case Diagram&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A use case diagram is a diagram that shows a set of &lt;strong&gt;use cases&lt;/strong&gt; and &lt;strong&gt;actors&lt;/strong&gt; and their &lt;strong&gt;relationships&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;UML modeling elements
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Use Cases&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Actors&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Dependency, generalization, and association relationships&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/UseCaseDiagram.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;use-cases-within-a-development-process&quot;&gt;Use Cases Within a Development Process&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Analysis phase&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Write expanded essential use cases for those currently being tackled, if not already done&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Design phase&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Write real use cases for those currently being tackled, if not already done&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;use-cases---why&quot;&gt;Use Cases - Why?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;User Actor 의 Goal 과 System Actor 의 Functional Requirement 를 파악하기 위해 Use Case 사용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;To give concrete examples of what we are supposed to be implementing&lt;/li&gt;
  &lt;li&gt;A basis for an agreement between the clients and the developers&lt;/li&gt;
  &lt;li&gt;A tool to make vague requirements more concrete&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A source for object analysis&lt;/strong&gt; ( Domain Analysis 의 Basic Step - Source 역할 )&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A source for the functionality of the system&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A unit for iterative &amp;amp; incremental software development&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The first version of the user’s guide&lt;/strong&gt; ( Use Case == User’s Guide )&lt;/li&gt;
  &lt;li&gt;The basis of system testing&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Tue, 18 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/UP-Development-1.-Inception-3</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/UP-Development-1.-Inception-3</guid>
			</item>
		
			<item>
				<title>Index Construction</title>
				<description>&lt;h1 id=&quot;index-construction&quot;&gt;Index Construction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;How do we construct an index?&lt;/li&gt;
  &lt;li&gt;What strategies can we use with limited main memory?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--hardware-basics&quot;&gt;- Hardware Basics&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Access to data in memory is much faster than access to data on disk&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk seeks&lt;/strong&gt; : No data is transferred from disk while the disk head is being positioned&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk I/O is block-based&lt;/strong&gt; : Reading and writing of entire blocks (as opposed to smaller chunks)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--can-we-use-the-same-index-construction-algorithm-for-larger-collections-but-by-using-disk-instead-of-memory&quot;&gt;- Can we use the same index construction algorithm for larger collections, but by using disk instead of memory?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;No , too many disk seeks needs ( &lt;strong&gt;Overhead&lt;/strong&gt; Increased )&lt;/li&gt;
  &lt;li&gt;So, We need an &lt;strong&gt;External Sorting Algorithm&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;blocked-sort-based-indexing--bsbi-&quot;&gt;Blocked Sort-Based Indexing ( BSBI )&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/BSBI.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Run : 처음부터 끝까지 Seek 한다 -&amp;gt; 디스크 Seek 한번만 필요하게 저장이 되어있는 경우&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
Disk 에서 Memory 로 한 Page 씩 읽어들임&lt;br /&gt;&lt;strong&gt;HIT / OS Caching ( 다음에 근처 Data 를 읽을 때 좀 더 빠르게 접근 가능 )&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;external-sorting-using-merge-sort&quot;&gt;External Sorting Using Merge Sort&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSort.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;M : Main Memory 에 들어갈 수 있는 공간&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
Using &lt;strong&gt;Quicksort&lt;/strong&gt; in Memory Pairs because mergesort has more memory space than &lt;strong&gt;Quicksort&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;--example-1-&quot;&gt;- Example 1 )&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSort2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--example-2-&quot;&gt;- Example 2 )&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSort3.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cost-analysis--io-&quot;&gt;Cost Analysis ( i/O )&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/costAnalysis.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cost-seek&quot;&gt;Cost Seek&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/costSeek.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercise&quot;&gt;Exercise&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSortExample.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 17 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/blocked-sort-based-indexing</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/blocked-sort-based-indexing</guid>
			</item>
		
			<item>
				<title>N - Gram Overlap</title>
				<description>&lt;h1 id=&quot;n---gram-overlap&quot;&gt;N - Gram Overlap&lt;/h1&gt;
&lt;p&gt;Use the n-gram index (recall wild-card search) to &lt;strong&gt;retrieve all lexicon terms matching any of the query n-grams&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Example )&lt;/p&gt;
&lt;pre&gt;
Trigrams
* november -&amp;gt; nov, ove, vem, emb, mbe, ber
* december -&amp;gt; dec, ece, cem, emb, mbe, ber
&lt;br /&gt;--&amp;gt; emb, mbe, ber 3 trigrams overlap ( of 6 in each term )
&lt;/pre&gt;

&lt;h3 id=&quot;--simple-lower-bound-of-substring-edit-distance&quot;&gt;- Simple Lower Bound of Substring Edit Distance&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;정확하진 않지만 Lower Bound ( 근사값 ) - The minimun number of edit operations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/SimpleLowerBound.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;
Trigrams --&amp;gt; n == 3

∂ = Jackson Pollock ( len = 15 )
s = JalksenPollock

Jac, ack, cks, kso, son, on_, n_P, _Po
Jal, alk, lks, kse, sen, enP, nPo, Pol&amp;nbsp;&amp;nbsp;===&amp;gt;&amp;nbsp;8 mismatching trigrams

Pol, oll, llo, loc, ock ===&amp;gt; 5 matching trigrams ( = c )

max(|s|,|∂|) - n + 1 - c = max(14,15) - 3 + 1 - 5 = 8

So, Simple Lower Bound of Substring Edit Distance is [8/3] = 3
&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;soundex&quot;&gt;SOUNDEX&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Class of heuristics to expand a query into phonetic equivalents&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
발음이 동등한지 여부를 판단한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Retain the first letter of the word ( &lt;strong&gt;첫 글자는 생략&lt;/strong&gt; )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Change all occurrences of the following letters to ‘0’ (zero)
    &lt;ul&gt;
      &lt;li&gt;A, E, I, O, U, H, W, Y&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Change letters to digits as follows
    &lt;ul&gt;
      &lt;li&gt;B, F, P, V : 1&lt;/li&gt;
      &lt;li&gt;C,G,J,K,Q,S,X,Z : 2&lt;/li&gt;
      &lt;li&gt;D,T : 3&lt;/li&gt;
      &lt;li&gt;L : 4&lt;/li&gt;
      &lt;li&gt;M, N : 5&lt;/li&gt;
      &lt;li&gt;R : 6&lt;br /&gt;
–&amp;gt; 외울 필요 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Repeatedly remove one out of each pair of consecutive identical digits.( &lt;strong&gt;반복되는 Pair 제거&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;Remove all zeros from the resulting string ( &lt;strong&gt;0 모두 지움&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;Pad the resulting string with trailing zeros and return the first four positions ( &lt;strong&gt;길이 맞추기 위해 0 padding&lt;/strong&gt; )&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
Example )&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/soundex.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-queries-can-we-process&quot;&gt;What queries can we process?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Positional inverted index with skip pointers&lt;/li&gt;
  &lt;li&gt;Wild-card index&lt;/li&gt;
  &lt;li&gt;Spell-correction&lt;/li&gt;
  &lt;li&gt;Soundex&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Query Search Engine Such as (SPELL(moriset) /3 toron*to) OR&lt;br /&gt;
SOUNDEX(chaikofski) …&lt;/p&gt;
</description>
				<pubDate>Sun, 16 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/n-gram-overlap</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/n-gram-overlap</guid>
			</item>
		
			<item>
				<title>Angular2 Component</title>
				<description>&lt;h1 id=&quot;angular-component&quot;&gt;Angular Component&lt;/h1&gt;
&lt;p&gt;Angular Component 는 &lt;strong&gt;Web Component 기술&lt;/strong&gt;을 기반으로 구성되며 &lt;br /&gt;기존 블록 엘리먼트 구조를 &lt;strong&gt;Component 구조&lt;/strong&gt;로 전환시켜 개발한다.&lt;/p&gt;

&lt;h4 id=&quot;--중첩-component&quot;&gt;- 중첩 Component&lt;/h4&gt;
&lt;p&gt;자식 Component 와 부모 Component 를 사용&lt;br /&gt;부모 Component 가 여러 자식 Component 를 포함할 때 부모 Component = 중첩 Component&lt;/p&gt;
&lt;h4 id=&quot;--component-tree&quot;&gt;- Component Tree&lt;/h4&gt;
&lt;p&gt;Component 끼리의 관계를 나타내는 것으로 Component 사이의 의존성이 존재할 수 있다.&lt;/p&gt;
&lt;h4 id=&quot;--component-기반-개발&quot;&gt;- Component 기반 개발&lt;/h4&gt;
&lt;pre&gt;
@Component({
	// 컴포넌트 메타 데이터 설정
})
export class HelloComponent {
	// 컴포넌트 로직 작성
}
&lt;/pre&gt;
&lt;p&gt;&amp;lt; Web Component 기술 요소 &amp;gt;&lt;br /&gt;
—–&lt;/p&gt;
&lt;h4 id=&quot;--html-템플릿&quot;&gt;- HTML 템플릿&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Angular 의 템플릿은 Web Component 기술의 템플릿 기술을 이용한다.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&amp;lt; template id=&quot;nav-item-template&quot;&amp;gt;
	&amp;lt; div class=&quot;nav&quot;&amp;gt;
		&amp;lt; div class=&quot;item&quot;&amp;gt;메인&amp;lt;/div&amp;gt;
		&amp;lt; div class=&quot;item&quot;&amp;gt;서비스 소개&amp;lt;/div&amp;gt;
		&amp;lt; div class=&quot;item&quot;&amp;gt;서비스 특징&amp;lt;/div&amp;gt;
	&amp;lt; /div&amp;gt;
&amp;lt; /template&amp;gt;
&lt;/pre&gt;
&lt;h4 id=&quot;--템플릿-호출&quot;&gt;- 템플릿 호출&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Angular 에서 템플릿 호출 기능은 Web Component 호출 기술을 이용한다.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&amp;lt; head&amp;gt;
&amp;lt; link rel=&quot;import&quot; href=&quot;template.html&quot;&amp;gt;
&amp;lt; /head&amp;gt;
...
&amp;lt; script&amp;gt;
	var link = document.quertSelector('link[re]=&quot;import&quot;]');
	var content = link.import;
	var el = content.querySelector('#template');
	document.body.appendChild(el.cloneNode(true));
&amp;lt; /script&amp;gt;
&lt;/pre&gt;
&lt;h4 id=&quot;--쉐도우-dom&quot;&gt;- 쉐도우 DOM&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Angular Component 는 쉐도우 DOM 을 사용하여 문서 트리에 영향을 받지 않는 쉐도우 DOM 을 이용한다.&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
DOM 은 크게 문서 DOM 과 쉐도우 DOM 으로 나누어진다.&lt;br /&gt;&lt;br /&gt;
문서 DOM 은 현재 페이지에 대한 DOM 이며, 쉐도우 DOM 은 웹 페이지가 실행되는 중 생성되는 가상 DOM 이다.&lt;/p&gt;
&lt;h4 id=&quot;--커스텀-엘리먼트&quot;&gt;- 커스텀 엘리먼트&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Angular Component 의 엘리먼트 이름은 Web Component 의 커스텀 엘리먼트 기술을  이용한다.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&amp;lt; hello-button&amp;gt;&amp;lt; /hello-button&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
 &lt;/p&gt;

&lt;h1 id=&quot;angular-component-구조&quot;&gt;Angular Component 구조&lt;/h1&gt;
&lt;h3 id=&quot;--import-영역&quot;&gt;- Import 영역&lt;/h3&gt;
&lt;pre&gt;
import { Component } from '@angular/core'; 
&lt;/pre&gt;
&lt;p&gt;Angular 라이브러리 모듈을 호출하거나 사용자 모듈을 호출할때 Import 키워드를 사용한다.&lt;br /&gt;&lt;br /&gt;
Angular 라이브러리 모듈은 &lt;strong&gt;@&lt;/strong&gt; 를 붙이며 사용자 모듈은 &lt;strong&gt;./&lt;/strong&gt; 을 통해 외부 모듈을 호출한다.&lt;/p&gt;

&lt;h3 id=&quot;--component-장식자-영역&quot;&gt;- Component 장식자 영역&lt;/h3&gt;
&lt;pre&gt;
@Component({
	selector : 'intro -component',
	template : '&amp;lt; div&amp;gt;App Hello&amp;lt; /div&amp;gt;',
	styles : ['div{ background: blue; }']
})
export class AppHello { }
&lt;/pre&gt;
&lt;p&gt;@Component 는 Component 장식자라고 불리며 위와 같은 형식을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;selector 속성&lt;br /&gt;Component 의 이름을 정의. &amp;lt; intro -component&amp;gt;&amp;lt; /intro -component&amp;gt; 같은 형식으로 정의&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;template 속성&lt;br /&gt;Component 에서 가장 중요한 속성이며 UI 코드를 정의한다.&lt;br /&gt;&lt;strong&gt;template&lt;/strong&gt; : 내부 파일에 HTML 과 템플릿 문법을 이용해 템플릿을 정의한다.&lt;br /&gt;&lt;strong&gt;templateUrl&lt;/strong&gt; : 외부 파일에 HTML 과 템플릿 문법을 이용해 템플릿을 정의한다.&lt;/li&gt;
  &lt;li&gt;style 속성&lt;br /&gt;템플릿에 스타일을 추가하기위해 CSS 스타일을 설정한다.&lt;br /&gt;&lt;strong&gt;styles&lt;/strong&gt; : 템플릿에 대한 스타일을 현재 파일 내부에 정의한다.&lt;br /&gt;&lt;strong&gt;styleUrl&lt;/strong&gt; : 템플릿에 대한 스타일을 외부 CSS 파일에 정의한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--component-class-영역&quot;&gt;- Component Class 영역&lt;/h3&gt;
&lt;p&gt;Component Class 에서는 템플릿 데이터 출력과 관련된 로직을 처리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부에 정의된 HTTP 서비스를 이용해 HTTP 요청 결과를 받아 템플릿에 데이터를 반영하는 로직&lt;/li&gt;
  &lt;li&gt;템플릿으로부터 클릭 이벤트를 받아 클릭 이벤트에 대한 처리를 수행하는 로직&lt;/li&gt;
  &lt;li&gt;템플릿에 사용할 데이터를 다른 Component 로 부터 전달 받아 이를 처리하는 로직&lt;/li&gt;
  &lt;li&gt;바인딩 변수를 이용해 권한에 따라 템플릿에서 화면 제어를 담당하는 로직&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 13 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/Angular2-Component</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/Angular2-Component</guid>
			</item>
		
			<item>
				<title>UP Development - 1.Inception (Cont'd)</title>
				<description>&lt;h1 id=&quot;up-development---1inception-contd&quot;&gt;UP Development - 1.Inception (Cont’d)&lt;/h1&gt;
&lt;h3 id=&quot;--a-use-case-contains-the-set-of-possible-scenarios-for-achieving-a-goal&quot;&gt;- A Use Case contains the set of possible scenarios for achieving a goal&lt;/h3&gt;

&lt;h3 id=&quot;--the-use-case-pulls-goals-and-scenarios-together-each-scenario-says-how-1-condition-unfolds&quot;&gt;- The Use Case pulls Goals and Scenarios together, Each scenario says how 1 condition unfolds&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The Use Case &lt;strong&gt;Name&lt;/strong&gt; is the goal statement&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use Case is goal statement plus the scenarios&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Use Case : &lt;strong&gt;Goal Statement 와 실현 가능한 시나리오들을 한데 묶은 것이다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--scenario-들을-묶은-것은-성공과-실패로-이루어져-있다&quot;&gt;- Scenario 들을 묶은 것은 성공과 실패로 이루어져 있다.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/collectedScenarios.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;--business-uc-vs-system-uc&quot;&gt;- Business UC vs System UC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Business UseCase : &lt;strong&gt;Describe the operations of the business&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;System UseCase : &lt;strong&gt;Describe the functional requirement for the SuD ( System Under Design )&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--black-box-uc-vs-white-box-uc&quot;&gt;- Black Box UC vs White Box UC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Black Box UseCase
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;System 을 모르는 상태&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Do not describe the internal workings of the system, its components, or design&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;White Box UseCase
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;System 을 아는 상태&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Can describe the internal workings of the system, its components, or design&lt;/li&gt;
      &lt;li&gt;Business process designers may write &lt;strong&gt;white-box business usecase&lt;/strong&gt; to show how the company or organization runs its internal process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--use-case-formats&quot;&gt;- Use Case Formats&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Brief Format&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;간결한 one-paragraph summary&lt;/li&gt;
      &lt;li&gt;usually of the main success scenario&lt;/li&gt;
      &lt;li&gt;created in early requirements phase to understand the degree of complexity and functionality in a system&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Casual Format&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Informal ( 약식의 ) parargraph format&lt;/li&gt;
      &lt;li&gt;Multiple paragraphs that cover various scenarios&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fully Dressed Format&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The most elaborate ( 가장 정교함 )&lt;/li&gt;
      &lt;li&gt;All steps and variations are written in detail&lt;/li&gt;
      &lt;li&gt;there are supporting sections, such as preconditions and success guarantess.&lt;br /&gt;( 성공 조건과 전제조건 같은 부가 섹션이 정의되어 있다 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--the-use-case-is-a-behavioral-part-of-the-contract-between-various-stakeholders&quot;&gt;- The Use Case is a behavioral part of the contract between various stakeholders&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Stakeholder : The stakeholder who or which initiates an interaction with the SuD or calls upon system services to achieve a goal.&lt;/li&gt;
  &lt;li&gt;An Action or an &lt;strong&gt;Interaction&lt;/strong&gt; between two &lt;strong&gt;Actors with Goals&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;What the system must do internally to protect the &lt;strong&gt;Stackholders with interests&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--the-basic-model-of-use-cases-is-that-actors-interact-to-achieve-their-goals&quot;&gt;- The basic model of Use Cases is that Actors interact to achieve their goals&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ActorsInteract.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Main Goal 을 성취하기 위해서는 Sub Goal 을 먼저 성취하여야 한다&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;--the-system-protects-the-interests-of-all-the-stackholders&quot;&gt;- The System protects the interests of all the stackholders&lt;/h3&gt;

&lt;h3 id=&quot;--a-use-case-can-be-viewed-as-a-behavioral-contract-between-stakeholders-with-interests&quot;&gt;- A Use Case can be viewed as a behavioral contract between stakeholders with interests&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;strong&gt;Actors and Goals&lt;/strong&gt; model explains how to write sentences in use case, but it &lt;strong&gt;Does not cover the need to describe the Internal behavior&lt;/strong&gt; of the system under discussion&lt;/li&gt;
  &lt;li&gt;We need to extend the Actors and Goals model to &lt;strong&gt;Stakeholders and Interests&lt;/strong&gt; model&lt;/li&gt;
  &lt;li&gt;Stakeholders and Interests model identifies what to include in the UseCase&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--to-satisfy-the-interests-of-the-stakeholders-we-need-to-describe-three-sorts-of-actions&quot;&gt;- To satisfy the interests of the stakeholders, we need to describe three sorts of actions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;An Action or Interaction between two actors( to further a goal )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A validation ( to protect the interest of one of the stakeholders )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;An internal state change ( on behalf of a stakeholder also to protect or further an interest of a stakeholder )&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--primpary-acotr-도-stakeholder-이다&quot;&gt;- Primpary Acotr 도 Stakeholder 이다.&lt;/h3&gt;

&lt;h3 id=&quot;--preconditions-and-postconditions&quot;&gt;- Preconditions and Postconditions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Preconditions&lt;/strong&gt; state what must always be true before beginning a scenario in the Use Case. They are conditions that are assumed to be true&lt;br /&gt;( UseCase 가 실행되기 전 실행해야 하는 것 )&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Postconditions&lt;/strong&gt; state what must be true on successful completion of the Use Case, regardless of its path&lt;br /&gt;( 사전 조건이 만족되었을때 UseCase 가 끝나고 실행되어야 할 것 )&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 12 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/UP-Development-1.-Inception-2</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/UP-Development-1.-Inception-2</guid>
			</item>
		
			<item>
				<title>Spelling Correction</title>
				<description>&lt;h1 id=&quot;spelling-correction&quot;&gt;Spelling Correction&lt;/h1&gt;

&lt;h3 id=&quot;--isolated-word&quot;&gt;- Isolated Word&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Check each word on its own for misspelling&lt;/li&gt;
  &lt;li&gt;Will not catch typos resulting in correctly spelled words&lt;br /&gt;( from -&amp;gt; form 둘 다 존재하는 단어이기 때문에 무엇이 맞는지 모른다. )&lt;/li&gt;
  &lt;li&gt;So cannot find correctly spelled words&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--context-sensitive&quot;&gt;- Context Sensitive&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Look at surrounding words&lt;/li&gt;
  &lt;li&gt;Complexity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;isolated-word-correction&quot;&gt;Isolated Word Correction&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Fundamental premise - there is a lexicon from which the correct speelings come&lt;/li&gt;
  &lt;li&gt;Two basic choices for this
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;A Standard Lexicon&lt;/strong&gt;&lt;br /&gt;( 사전에 있는 단어인지 체크 후 없다면 비슷한 단어로 고침 )&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;The Lexicon of the indexed corpus&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;--3-kinds-of-several-alternatives&quot;&gt;- 3 kinds of several alternatives&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Edit Distance (Levenshtein Distance)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Weighted Edit Distance&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;N-gram overlap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-edit-distance-&quot;&gt;&amp;lt; Edit Distance &amp;gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Give two strings S1 and S2, the minimum number of operations to convert one to the other&lt;/li&gt;
  &lt;li&gt;Operations are typically character-level&lt;br /&gt;&lt;strong&gt;Insert, Delete, Replace&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
				Edit Distance
dof , dog ==&amp;gt;		  1
cat , act ==&amp;gt;		  2
cat , dog ==&amp;gt;		  3
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Generally found by &lt;strong&gt;Dynamic Programming&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--levenshtein&quot;&gt;- Levenshtein&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Edit Distance Metrics
    &lt;ul&gt;
      &lt;li&gt;Distance is shortest sequence of edit commands that transform s to t.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simplest set of operations
    &lt;ul&gt;
      &lt;li&gt;Copy char from s over to t&lt;/li&gt;
      &lt;li&gt;Delete char in s ( cost 1 )&lt;/li&gt;
      &lt;li&gt;Insert char in t ( cost 1 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Levenshtein.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--dynamic-algorithm&quot;&gt;- Dynamic Algorithm&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Levenshtein2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;==&amp;gt; &lt;strong&gt;d(s(i),t(j))&lt;/strong&gt; : s(i) 와  t(j) 를  비교하여 같다면 &lt;strong&gt;0&lt;/strong&gt; 다르다면  &lt;strong&gt;1&lt;/strong&gt; 를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/editDistanceAlgorithm.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;==&amp;gt; &lt;strong&gt;this algorithm has O(m-n) time Complexity&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
==&amp;gt; &lt;strong&gt;c(s(i),t(j))&lt;/strong&gt; : a(i) 와  b(j) 를  비교하여 같다면 &lt;strong&gt;0&lt;/strong&gt; 다르다면  &lt;strong&gt;1&lt;/strong&gt; 를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/editDistanceEx.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 10 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/spelling-correction</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/spelling-correction</guid>
			</item>
		
			<item>
				<title>UP Development - 1.Inception</title>
				<description>&lt;h1 id=&quot;up-development---1inception&quot;&gt;UP Development - 1.Inception&lt;/h1&gt;
&lt;p&gt;Most Project require a short initial step in which the following kinds of questions are explored&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What is the vision and business case for this project?&lt;/li&gt;
  &lt;li&gt;Feasible?&lt;/li&gt;
  &lt;li&gt;Buy and/or Build?&lt;/li&gt;
  &lt;li&gt;Rough estimate of cost&lt;/li&gt;
  &lt;li&gt;Should we proceed or stop?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;--artifacts-in-inception-phase&quot;&gt;- Artifacts in Inception Phase&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Use-Case Model&lt;/strong&gt; : Describe functional requirements, and related non-functional requirements&lt;/p&gt;

&lt;h3 id=&quot;--useful-classification&quot;&gt;- Useful Classification&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Functional requirements vs Non-functional requirements&lt;/li&gt;
  &lt;li&gt;Most of the non-functional requirements are collectively called as &lt;strong&gt;Quality Attributes&lt;/strong&gt; or &lt;strong&gt;Quality Requirements&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Functional requirements are explored and recorded in the &lt;strong&gt;Use-Case Model&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Other requirements can be recorded in the use cases they relate to, or in the &lt;strong&gt;Supplementary Specifications&lt;/strong&gt; artifacts.&lt;/li&gt;
  &lt;li&gt;The &lt;strong&gt;Vision&lt;/strong&gt; artifact summarizes high-level requirements.&lt;/li&gt;
  &lt;li&gt;The &lt;strong&gt;Glossary&lt;/strong&gt; encompasses the concept of &lt;strong&gt;Data dictionary&lt;/strong&gt; which records requirements related to data, such as validation rules, acceptable values, and so forth.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--motivation-for-use-cases&quot;&gt;- Motivation for Use Cases&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;We need a tool to analyze, record, and improve functional requirements&lt;/li&gt;
  &lt;li&gt;Developers must know exactly what they are going to implement&lt;/li&gt;
  &lt;li&gt;A Client must understand what will be implemented&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==&amp;gt; Solution : &lt;strong&gt;Use Case&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;--goals-and-stories&quot;&gt;- Goals and Stories&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Clients and End users have &lt;strong&gt;Goals (Needs)&lt;/strong&gt; and want the system to help meet them.&lt;/li&gt;
  &lt;li&gt;Informally, Use Cases are &lt;strong&gt;Stories of using a system to meet goals&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;The most effective way to capture the &lt;strong&gt;Goals&lt;/strong&gt; and system’s &lt;strong&gt;Functional requirements&lt;/strong&gt; is writing &lt;strong&gt;Use Cases&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--actors&quot;&gt;- Actors&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Basic Definition&lt;br /&gt;An Actor is anything outside SuD that interacts with SuD.&lt;/li&gt;
  &lt;li&gt;Extended Definition&lt;br /&gt;An Actor is anything with behavior, including the SuD itself when it calls on the services of other actors&lt;/li&gt;
  &lt;li&gt;In case of a person acotr, it represents a &lt;strong&gt;role&lt;/strong&gt; that the person plays when interaction with these use cases.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--types-of-actors&quot;&gt;- Types of Actors&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Primary Actors&lt;/strong&gt;&lt;br /&gt;Goals 을 달성 하기 위해 System 을 이용함.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Supporting Acotrs&lt;/strong&gt;&lt;br /&gt;Primary Actor 를 도와주기 위해 System 을 이용함.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Offstage Actors&lt;/strong&gt;&lt;br /&gt;It has an interest in the behavior of the use case, but is not primary or supporting actors&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--scenarios--하나의-특정-사례-&quot;&gt;- Scenarios ( 하나의 특정 사례 )&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;strong&gt;Scenario ( use case instance )&lt;/strong&gt; is a specific sequence of actions and interactions between actors and the SuD to meet a common goal&lt;/li&gt;
  &lt;li&gt;It is one particular story of using a system, or one path through the use case.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--use-cases&quot;&gt;- Use Cases&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Informally, Use Case is a collection of related success and failure scenarios that describes actors using a system to support a goal&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UP Definition&lt;/strong&gt; : Use Case is a set of use-case instances, where each instance is a sequence of actions that yields an &lt;strong&gt;Observable Result of Value (Benefits)&lt;/strong&gt; to a particular actor&lt;/li&gt;
  &lt;li&gt;Use Cases document the behavior ( Functional Requirements ) of the system &lt;strong&gt;From the User’s Point of View&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;A software product implements a set of use cases&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Sat, 08 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/UP-Development-1.-Inception</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/UP-Development-1.-Inception</guid>
			</item>
		
	</channel>
</rss>