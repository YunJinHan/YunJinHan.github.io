<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>JinHan's Blog</title>
		<description>Software Developer</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Index Construction</title>
				<description>&lt;h1 id=&quot;index-construction&quot;&gt;Index Construction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;How do we construct an index?&lt;/li&gt;
  &lt;li&gt;What strategies can we use with limited main memory?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--hardware-basics&quot;&gt;- Hardware Basics&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Access to data in memory is much faster than access to data on disk&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk seeks&lt;/strong&gt; : No data is transferred from disk while the disk head is being positioned&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk I/O is block-based&lt;/strong&gt; : Reading and writing of entire blocks (as opposed to smaller chunks)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--can-we-use-the-same-index-construction-algorithm-for-larger-collections-but-by-using-disk-instead-of-memory&quot;&gt;- Can we use the same index construction algorithm for larger collections, but by using disk instead of memory?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;No , too many disk seeks needs ( &lt;strong&gt;Overhead&lt;/strong&gt; Increased )&lt;/li&gt;
  &lt;li&gt;So, We need an &lt;strong&gt;External Sorting Algorithm&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;blocked-sort-based-indexing--bsbi-&quot;&gt;Blocked Sort-Based Indexing ( BSBI )&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/BSBI.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Run : 처음부터 끝까지 Seek 한다 -&amp;gt; 디스크 Seek 한번만 필요하게 저장이 되어있는 경우&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
Disk 에서 Memory 로 한 Page 씩 읽어들임&lt;br /&gt;&lt;strong&gt;HIT / OS Caching ( 다음에 근처 Data 를 읽을 때 좀 더 빠르게 접근 가능 )&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;external-sorting-using-merge-sort&quot;&gt;External Sorting Using Merge Sort&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSort.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;M : Main Memory 에 들어갈 수 있는 공간&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
Using &lt;strong&gt;Quicksort&lt;/strong&gt; in Memory Pairs because mergesort has more memory space than &lt;strong&gt;Quicksort&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;--example-1-&quot;&gt;- Example 1 )&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSort2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--example-2-&quot;&gt;- Example 2 )&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSort3.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cost-analysis--io-&quot;&gt;Cost Analysis ( i/O )&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/costAnalysis.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cost-seek&quot;&gt;Cost Seek&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/costSeek.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercise&quot;&gt;Exercise&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/ExternalMergeSortExample.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 17 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/blocked-sort-based-indexing</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/blocked-sort-based-indexing</guid>
			</item>
		
			<item>
				<title>N - Gram Overlap</title>
				<description>&lt;h1 id=&quot;n---gram-overlap&quot;&gt;N - Gram Overlap&lt;/h1&gt;
&lt;p&gt;Use the n-gram index (recall wild-card search) to &lt;strong&gt;retrieve all lexicon terms matching any of the query n-grams&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Example )&lt;/p&gt;
&lt;pre&gt;
Trigrams
* november -&amp;gt; nov, ove, vem, emb, mbe, ber
* december -&amp;gt; dec, ece, cem, emb, mbe, ber
&lt;br /&gt;--&amp;gt; emb, mbe, ber 3 trigrams overlap ( of 6 in each term )
&lt;/pre&gt;

&lt;h3 id=&quot;--simple-lower-bound-of-substring-edit-distance&quot;&gt;- Simple Lower Bound of Substring Edit Distance&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;정확하진 않지만 Lower Bound ( 근사값 ) - The minimun number of edit operations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/SimpleLowerBound.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;
Trigrams --&amp;gt; n == 3

∂ = Jackson Pollock ( len = 15 )
s = JalksenPollock

Jac, ack, cks, kso, son, on_, n_P, _Po
Jal, alk, lks, kse, sen, enP, nPo, Pol&amp;nbsp;&amp;nbsp;===&amp;gt;&amp;nbsp;8 mismatching trigrams

Pol, oll, llo, loc, ock ===&amp;gt; 5 matching trigrams ( = c )

max(|s|,|∂|) - n + 1 - c = max(14,15) - 3 + 1 - 5 = 8

So, Simple Lower Bound of Substring Edit Distance is [8/3] = 3
&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;soundex&quot;&gt;SOUNDEX&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Class of heuristics to expand a query into phonetic equivalents&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
발음이 동등한지 여부를 판단한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Retain the first letter of the word ( &lt;strong&gt;첫 글자는 생략&lt;/strong&gt; )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Change all occurrences of the following letters to ‘0’ (zero)
    &lt;ul&gt;
      &lt;li&gt;A, E, I, O, U, H, W, Y&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Change letters to digits as follows
    &lt;ul&gt;
      &lt;li&gt;B, F, P, V : 1&lt;/li&gt;
      &lt;li&gt;C,G,J,K,Q,S,X,Z : 2&lt;/li&gt;
      &lt;li&gt;D,T : 3&lt;/li&gt;
      &lt;li&gt;L : 4&lt;/li&gt;
      &lt;li&gt;M, N : 5&lt;/li&gt;
      &lt;li&gt;R : 6&lt;br /&gt;
–&amp;gt; 외울 필요 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Repeatedly remove one out of each pair of consecutive identical digits.( &lt;strong&gt;반복되는 Pair 제거&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;Remove all zeros from the resulting string ( &lt;strong&gt;0 모두 지움&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;Pad the resulting string with trailing zeros and return the first four positions ( &lt;strong&gt;길이 맞추기 위해 0 padding&lt;/strong&gt; )&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
Example )&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/soundex.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-queries-can-we-process&quot;&gt;What queries can we process?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Positional inverted index with skip pointers&lt;/li&gt;
  &lt;li&gt;Wild-card index&lt;/li&gt;
  &lt;li&gt;Spell-correction&lt;/li&gt;
  &lt;li&gt;Soundex&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Query Search Engine Such as (SPELL(moriset) /3 toron*to) OR&lt;br /&gt;
SOUNDEX(chaikofski) …&lt;/p&gt;
</description>
				<pubDate>Sun, 16 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/n-gram-overlap</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/n-gram-overlap</guid>
			</item>
		
			<item>
				<title>Spelling Correction</title>
				<description>&lt;h1 id=&quot;spelling-correction&quot;&gt;Spelling Correction&lt;/h1&gt;

&lt;h3 id=&quot;--isolated-word&quot;&gt;- Isolated Word&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Check each word on its own for misspelling&lt;/li&gt;
  &lt;li&gt;Will not catch typos resulting in correctly spelled words&lt;br /&gt;( from -&amp;gt; form 둘 다 존재하는 단어이기 때문에 무엇이 맞는지 모른다. )&lt;/li&gt;
  &lt;li&gt;So cannot find correctly spelled words&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--context-sensitive&quot;&gt;- Context Sensitive&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Look at surrounding words&lt;/li&gt;
  &lt;li&gt;Complexity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;isolated-word-correction&quot;&gt;Isolated Word Correction&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Fundamental premise - there is a lexicon from which the correct speelings come&lt;/li&gt;
  &lt;li&gt;Two basic choices for this
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;A Standard Lexicon&lt;/strong&gt;&lt;br /&gt;( 사전에 있는 단어인지 체크 후 없다면 비슷한 단어로 고침 )&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;The Lexicon of the indexed corpus&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;--3-kinds-of-several-alternatives&quot;&gt;- 3 kinds of several alternatives&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Edit Distance (Levenshtein Distance)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Weighted Edit Distance&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;N-gram overlap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-edit-distance-&quot;&gt;&amp;lt; Edit Distance &amp;gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Give two strings S1 and S2, the minimum number of operations to convert one to the other&lt;/li&gt;
  &lt;li&gt;Operations are typically character-level&lt;br /&gt;&lt;strong&gt;Insert, Delete, Replace&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
				Edit Distance
dof , dog ==&amp;gt;		  1
cat , act ==&amp;gt;		  2
cat , dog ==&amp;gt;		  3
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Generally found by &lt;strong&gt;Dynamic Programming&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;--levenshtein&quot;&gt;- Levenshtein&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Edit Distance Metrics
    &lt;ul&gt;
      &lt;li&gt;Distance is shortest sequence of edit commands that transform s to t.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simplest set of operations
    &lt;ul&gt;
      &lt;li&gt;Copy char from s over to t&lt;/li&gt;
      &lt;li&gt;Delete char in s ( cost 1 )&lt;/li&gt;
      &lt;li&gt;Insert char in t ( cost 1 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Levenshtein.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--dynamic-algorithm&quot;&gt;- Dynamic Algorithm&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Levenshtein2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;==&amp;gt; &lt;strong&gt;d(s(i),t(j))&lt;/strong&gt; : s(i) 와  t(j) 를  비교하여 같다면 &lt;strong&gt;0&lt;/strong&gt; 다르다면  &lt;strong&gt;1&lt;/strong&gt; 를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/editDistanceAlgorithm.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;==&amp;gt; &lt;strong&gt;this algorithm has O(m-n) time Complexity&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
==&amp;gt; &lt;strong&gt;c(s(i),t(j))&lt;/strong&gt; : a(i) 와  b(j) 를  비교하여 같다면 &lt;strong&gt;0&lt;/strong&gt; 다르다면  &lt;strong&gt;1&lt;/strong&gt; 를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/editDistanceEx.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 10 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/spelling-correction</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/spelling-correction</guid>
			</item>
		
			<item>
				<title>Wild - Card Queries</title>
				<description>&lt;h1 id=&quot;wild---card-queries&quot;&gt;Wild - Card Queries&lt;/h1&gt;
&lt;h3 id=&quot;--------&quot;&gt;- “ * “ / “ $ “&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;” * “ means 0 or more occurrences&lt;/li&gt;
  &lt;li&gt;” $ “ represents the end ( m$ : m 으로 끝남 , $m : m 으로 시작함 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;pre&gt;
mon* : find all docs containing any word beginning with &quot;mon&quot;
&lt;/pre&gt;
&lt;p&gt;Easy with Binary tree ( or B+ Tree ) lexicon ( 사전 ) : retrieve all words in range : mon &amp;lt;= w &amp;lt; moo&lt;/p&gt;
&lt;pre&gt;
*mon : find words ending in &quot;mon&quot; : harder
&lt;/pre&gt;
&lt;p&gt;Maintain an additional B+ Tree for terms backwards&lt;/p&gt;

&lt;h3 id=&quot;--query-processing&quot;&gt;- Query Processing&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;At this point, we have an enumeration of all terms in the &lt;strong&gt;Dictionary&lt;/strong&gt; that match the wild-card query&lt;/li&gt;
  &lt;li&gt;We still have to look up the postings for each enumerated term&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;pre&gt;
se * ate
se *  AND * ate : This may result in the execution of many Boolean AND queries.
&lt;/pre&gt;
&lt;p&gt;–&amp;gt; Expensive ( B+ Tree 를 하나 더 사용하게 된다 )&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Solution : &lt;strong&gt;Transform wild-card queries so that the “ * “ occur at the end&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;This give rise to the &lt;strong&gt;Permuterm Index&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;--permuterm-index&quot;&gt;- Permuterm Index&lt;/h3&gt;

&lt;pre&gt;
From term hello, index under :
- hello$ , ello$h, llo$he, lo$hel, o$hell, $hello 
( 한칸씩 Shifting 하면서 해당 단어에 대한 Permuterm 을 전부 만든다 )
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;해당 Word 에 대해 모든 Permuterm 을  Dictinary 에 넣고 Search 시 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/permutermIndex.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;
Search H * llo
- hello -&amp;gt; llo$he, ...
- hillo -&amp;gt; llo$hi, ...
- haaallo -&amp;gt; llo$haaa, ...
--&amp;gt; 미리 Dictionary 에 정의된 단어들의 Permuterm 들 중 Search word 가 match 되는 것을 찾는 방식
&lt;/pre&gt;

&lt;p&gt;Exercise&lt;/p&gt;
&lt;pre&gt;
1. Write down the entries in the permuterm index dictionary that are generated by the term mama.
- ANS :  mama$, ama$m, ma$ma, a$mam, $mama
2. If you wanted to search for s*ng in a permuterm wildcard index, what key(s) would one do the lookup on?
- ANS : ng$s *
3.
 - Consider again the query fi * mo * er.
 - What Boolean query on a bigram index would be generated for this query?
 	- ANS : The Boolean query is $f AND fi AND mo AND er AND r$.
 - Can you think of a term that matches the permuterm query, but does not satisfy this Boolean query?
 	- ANS : The &quot;filibuster&quot; term will match the permuterm query, but does not satisfy this Boolean query
&lt;/pre&gt;

&lt;h3 id=&quot;--bigram--k---gram--indexes&quot;&gt;- Bigram ( k - gram ) Indexes&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Enumerate all k - grams ( sequence of k chars ) occuring in any term&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bigramEx.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$ is a special word boundary symbol&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Maintain a second inverted index from bigrams to dictionary terms that match each bigram&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bigramEx2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;pre&gt;
he * llo
- he -&amp;gt; hello, he, she, loche, ...
- lo -&amp;gt; hello, location, log, loche, ...
Check match he * lo ---&amp;gt; hello, loche, ...
&lt;/pre&gt;

&lt;h3 id=&quot;--processing-wild---cards&quot;&gt;- Processing wild - cards&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Query mon * can now be run as&lt;br /&gt;&lt;strong&gt;$m AND mo AND on&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Gets terms that match AND version of our wildcard query&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;But we may enumerate moon too!&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Must post-filter these terms against query.&lt;/li&gt;
      &lt;li&gt;Or positional index can handle this problem&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Surviving enumerated terms are then looked up in the term-document inverted index&lt;/li&gt;
  &lt;li&gt;Fast, space efficient ( Compared to permuterm )&lt;/li&gt;
  &lt;li&gt;As before, we must execute a Boolean query for each enumerated, filtered term&lt;/li&gt;
  &lt;li&gt;Wild-cards can result in expensive query execution (very large disjunctions…)&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Fri, 07 Apr 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/04/wild-card</link>
				<guid isPermaLink="true">http://localhost:4000/2017/04/wild-card</guid>
			</item>
		
			<item>
				<title>B+ Tree (cont'd)</title>
				<description>&lt;h2 id=&quot;insertion-in-b-trees&quot;&gt;Insertion in B+ Trees&lt;/h2&gt;
&lt;h3 id=&quot;--leaf-node-에-new-key-값이-insert-될-자리가-있을때&quot;&gt;- Leaf Node 에 New Key 값이 Insert 될 자리가 있을때&lt;/h3&gt;
&lt;p&gt;해당 New Key 값을 Order 에 맞게 자리를 찾아 Insert 한다.&lt;/p&gt;

&lt;h3 id=&quot;--leaf-node-에-new-key-값이-insert-될-자리가-없을때&quot;&gt;- Leaf Node 에 New Key 값이 Insert 될 자리가 없을때&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;해당 Node 의 values 가 꽉차서 Overflow 가 발생하게 된다&lt;/strong&gt; ==&amp;gt; &lt;strong&gt;Split 해준다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Example - Insert 8&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/b+_tree_insertion.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Splitting a Leaf Node
    &lt;ol&gt;
      &lt;li&gt;8 value 를 Insert 시 해당 Leaf Node 의 values 들이 2 3 5 7 8 이 되는데&lt;br /&gt;4 개를 초과하여 &lt;strong&gt;Overflow&lt;/strong&gt; 가 발생하게 된다.&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;기존의 Node A 에 P(1),K(1) ~ P(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;),K(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;) , P(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;+ 1 ) 까지 Copy 한다.&lt;br /&gt;(&lt;/td&gt;
              &lt;td&gt;A&lt;/td&gt;
              &lt;td&gt;= A 보다 큰 정수들 중 가장 작은 정수 )&lt;br /&gt;( n = 5,&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;= 3 , 결과 : [ 2, 3, 5 ])&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;새로운 Node B 를 만들어 P(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;),K (&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;) ~ P( n ), K( n ) , P( n + 1 ) 까지 Copy 한다.&lt;br /&gt;( 결과 : [ 7, 8 ] )&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;부모 노드에 K(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;+ 1 ) 값을 올린다. 왼쪽 자식 포인터는 A Node, 오른쪽 자식 포인터는 B Node 를 가르킨다.&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Splitting a Non Leaf Node ( Internal Node )&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;7 value 가 올라와서 해당 Internal Node ( 여기선 Root ) 의 values 들이 7 13 17 24 30 이 되는데 &lt;br /&gt;4 개를 초과하여 &lt;strong&gt;Overflow&lt;/strong&gt; 가 발생하게 된다.&lt;/li&gt;
      &lt;li&gt;올라온 값을 Insert 한다.&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;기존의 Node A 에 P(1),K(1) ~ P(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;- 1 ),K(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;- 1 ) , P(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;) 까지 Copy 한다.&lt;br /&gt;(&lt;/td&gt;
              &lt;td&gt;A&lt;/td&gt;
              &lt;td&gt;= A 보다 큰 정수들 중 가장 작은 정수 )&lt;br /&gt;( n = 5 ( 7, 13, 17, 24, 30 ),&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;= 3 ===&amp;gt; 결과 : [ 7, 13 ] )&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;새로운 Node B 를 만들어 P(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;+ 1 ),K(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;+ 1 ) ~ P(n),K(n) , P( n + 1 ) 를 Copy 한다.&lt;br /&gt;( 결과 : [ 24, 30 ] )&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;K(&lt;/td&gt;
              &lt;td&gt;n/2&lt;/td&gt;
              &lt;td&gt;) 값을 새로운 부모노드에 Insert 한 후 왼쪽 자식 포인터는 A Node, 오른쪽 자식 포인터는 B Node 를 가르킨다.&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;==&amp;gt; 가운데 값을 부모 노드로 올리고 양쪽의 값을 나누어 2개의 노드로 만든다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;deletion-in-b-trees&quot;&gt;Deletion in B+ Trees&lt;/h2&gt;
&lt;h3 id=&quot;--삭제-후-leaf-node-의-condition-이-유지되는-경우&quot;&gt;- 삭제 후 Leaf Node 의 Condition 이 유지되는 경우&lt;/h3&gt;
&lt;p&gt;해당 Key 값을 제거 한 후 해당 삭제가 발생된 Node 안에서 한칸씩 당겨 정렬한다.&lt;/p&gt;
&lt;h3 id=&quot;--삭제-후-leaf-node-의-condition-이-유지되지-않는-경우&quot;&gt;- 삭제 후 Leaf Node 의 Condition 이 유지되지 않는 경우&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/b+_tree_deletion1.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Re-distribution in Leaf Nodes&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;삭제 시 &lt;strong&gt;Underflow&lt;/strong&gt; 가 발생하게 된다.&lt;/li&gt;
      &lt;li&gt;형제 Node 에서 Key 값을 빌려온다. ( 왼쪽 형제이면 가장 큰 Key 를 , 오른쪽 형제이면 가장 작은 Key 를 빌려온다. )&lt;/li&gt;
      &lt;li&gt;해당 삭제가 발생한 Node 에 빌려온 Key 값을 넣고 &lt;strong&gt;빌려준 Node 에서는 가장 작거나 큰 값을 부모 노드로 밀어 올린다. ( Copy Up )&lt;/strong&gt;&lt;br /&gt;( ex. 18 을 빌려와 부모에서 18이 내려오고 19가 부모로 올라간다 –&amp;gt; 3단 밀어내기 )&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/b+_tree_deletion2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Merge in Leaf Nodes and Re-distribution in Non-leaf Nodes&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;삭제를 하였는데 형제 Node 에서 빌려올 Key 값이 없다.&lt;/li&gt;
      &lt;li&gt;해당 형제 노드들을 &lt;strong&gt;Merge&lt;/strong&gt; 한다.&lt;/li&gt;
      &lt;li&gt;부모에 Key 값이 한 개 있는 경우 ( Leaf Node 의 Key 값을 제외한 Key 값의 수 )
        &lt;ul&gt;
          &lt;li&gt;부모 또한 &lt;strong&gt;Merge&lt;/strong&gt; 를 시도한다. 실패 한다면 형제 부모 Node 에서 Key 값을 빌려온다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부모에 Key 값이 아무것도 없는 경우 ( Leaf Node 의 Key 값을 제외한 Key 값의 수 )
        &lt;ul&gt;
          &lt;li&gt;부모가 형제 부모 Node 에서 Key 값을 빌려온다. 실패 한다면 부모 또한 &lt;strong&gt;Merge&lt;/strong&gt; 를 시도한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;
&lt;h3 id=&quot;--delete-24&quot;&gt;- Delete 24&lt;/h3&gt;
&lt;p&gt;1.&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/b+_tree_deletion3.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/b+_tree_deletion3_1.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;try that N = 3 &amp;amp;&amp;amp; insert 6, 8, 5, 7, 4 &amp;amp;&amp;amp; delete 8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;delete 6 !!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
				<pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/03/b+-tree-(cont'd)</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/b+-tree-(cont'd)</guid>
			</item>
		
			<item>
				<title>B+ Tree</title>
				<description>&lt;h2 id=&quot;b-tree-node-structure&quot;&gt;B+ Tree Node Structure&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/b+_tree_structure.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;K(i) are the search-key values&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;P(i) are pointers to children (for non-leaf nodes) or pointers to records or buckets of records (for leaf nodes).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;leaf-nodes-in-b-trees&quot;&gt;Leaf Nodes in B+ Trees&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/leaf_node_structure.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Leaf Node 는 Increasing Order 로 정렬되어있으며,&lt;br /&gt;&lt;br /&gt;
한 마지막 Key 의 Pointer 는 다음 형제 Node 의 첫번째 Key 를 가르킨다.&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
위의 그림처럼 모든 Leaf Node 들의 고유 Pointer 는 file record 를 가르킨다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
B+ Tree 의 모든 Key 값은 Leaf Node 에 존재하며 Internal Node 에 존재하며  Leaf Node 에 존재하지 않는 Key 값도 존재할 수 있다.&lt;br /&gt;&lt;br /&gt;
–&amp;gt; Key 값 삭제시 Leaf Node 에서만 삭제하기 때문에 삭제된 Key 값이더라도 Internal Node 에 존재할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;non-leaf-nodes-in-b-trees&quot;&gt;Non Leaf Nodes in B+ Trees&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets//b+_tree_structure.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;All the search-keys in the subtree to which P(n) points have values greater than or equal to K(n–1)&lt;/p&gt;

&lt;h2 id=&quot;example-b-trees&quot;&gt;Example B+ Trees&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/b+_tree_example.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leaf Node 는 반드시 3개 이상 5개 이하의 Key 값을 가져야함.&lt;br /&gt;( A leaf node has between [(n−1)/2] and n–1 values )&lt;/li&gt;
  &lt;li&gt;Root Node 를 제외한 Non Leaf Node ( Internal Node ) 는 반드시 3개 이상 6개 이하의 Child Node 를 가져야함.&lt;br /&gt;( Each node that is not a root or a leaf has between [n/2] and n children )&lt;/li&gt;
  &lt;li&gt;Root Node 는 2개 이상의 Child Node 를 가져야함.&lt;br /&gt;( If the root is not a leaf, it has at least 2 children. )&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 25 Mar 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/03/b+-tree</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/b+-tree</guid>
			</item>
		
			<item>
				<title>Dictionaries and tolerant retrival</title>
				<description>&lt;h1 id=&quot;dictionaries-and-tolerant-retrival&quot;&gt;Dictionaries and tolerant retrival&lt;/h1&gt;

&lt;h2 id=&quot;hashtables&quot;&gt;Hashtables&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Each vocalulary term is hashed to an integer.&lt;/li&gt;
  &lt;li&gt;Procs : Lookup is faster than a tree =&amp;gt; O(1)&lt;/li&gt;
  &lt;li&gt;Cons : No easy way to find minor variants&lt;br /&gt;&lt;br /&gt;
       No prefix search&lt;br /&gt;&lt;br /&gt;
       if vocalbulary keeps growing, need to occasionally do the expensive operaiton of rehashing everything.&lt;br /&gt;&lt;br /&gt;
       &lt;strong&gt;Waste memory space&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
       &lt;strong&gt;In the worst case, it performs terribly&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
       &lt;strong&gt;Irregular search time&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;trees&quot;&gt;Trees&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Simplest Binary tree&lt;/li&gt;
  &lt;li&gt;More usual : B+ tree&lt;/li&gt;
  &lt;li&gt;Trees require a standard ordering of characters and hence strings … but, we typically have one&lt;/li&gt;
  &lt;li&gt;Pros : Solves the prefix problem (ex. terms starting with hany)&lt;br /&gt;
Optimized for disk-based retrieval&lt;/li&gt;
  &lt;li&gt;Cons : Slower =&amp;gt; O(logM) ( this requires balanced tree ) / Rebalancing binary trees is expensive&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;b-tree&quot;&gt;B+ tree&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Indexing mechanisms used to speed up access to desired data.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Search Key&lt;/strong&gt; : attribute to set of attributes used to look up records in a file&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Index file&lt;/strong&gt; : consists of records ( called index entries ) of them&lt;/li&gt;
  &lt;li&gt;TWO basic kind of indices :
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Ordered Indices&lt;/strong&gt; : search keys are stored in sorted order&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Hash indices&lt;/strong&gt; : search keys are distributed uniformly across “bucket” using a “hash function”&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;index-evaluataion-metrics&quot;&gt;Index Evaluataion Metrics&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Access types supported efficiently&lt;/li&gt;
  &lt;li&gt;Access time&lt;/li&gt;
  &lt;li&gt;Insertion time&lt;/li&gt;
  &lt;li&gt;Deletion time&lt;/li&gt;
  &lt;li&gt;Space overhead&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ordered-indics&quot;&gt;Ordered Indics&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;In an &lt;strong&gt;Ordered Index&lt;/strong&gt;, Index entries are stored sorted on the search key value&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Primary Index&lt;/strong&gt; (&lt;strong&gt;Clustering index&lt;/strong&gt;): in sequentially ordered fiel, this index whose search key specifies the sequential order of the file.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Secondary Index&lt;/strong&gt; (“non-clustering index”): ans index whose search by key specfiies an order diffent from the sequential of the file.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dense_index_files&quot;&gt;Dense_Index_Files&lt;/h2&gt;
&lt;p&gt;Dens-Index - Index record appears for every search-key value in the file.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/dense1.jpg&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dense index on dept_name, with instructor file sorted on dept_name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dense2.jpg&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sparse_index_files&quot;&gt;Sparse_Index_Files&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;contatins index records for only some search-key values&lt;/li&gt;
  &lt;li&gt;To locate a record with search key value k we&lt;br /&gt;&lt;br /&gt;
Find index record with search-key value K we&lt;br /&gt;&lt;br /&gt;
Search file sequentially starting at the reocord to which the index record points&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;secondary-indics&quot;&gt;Secondary Indics&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Indexed record points to a buket that contains pointer&lt;br /&gt;&lt;br /&gt;
to all the actual records with that particular search-key value&lt;/li&gt;
  &lt;li&gt;Secondary indics hav to be dense&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/SecondaryIndics.jpg&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;primary-and-secondary-indics&quot;&gt;Primary and Secondary Indics&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Indices offer substantial benefits when searching for records&lt;/li&gt;
  &lt;li&gt;BUT: Updating indices imposes &lt;strong&gt;overhead&lt;/strong&gt; on database modification when a file is modifided, every index on the file must be updated.&lt;/li&gt;
  &lt;li&gt;Sequential scan using primary index is efficient, but &lt;strong&gt;a sequential scan using a secondary index is expensive&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;multilevel-index&quot;&gt;Multilevel Index&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;If primary index does not fit in memory, access becomes expensive&lt;/li&gt;
  &lt;li&gt;Solution: treat primary index kept on disk as a sequential file and construct a sparse index on it.&lt;/li&gt;
  &lt;li&gt;outer index – a sparse index of primary index&lt;/li&gt;
  &lt;li&gt;inner index – the primary index file&lt;/li&gt;
  &lt;li&gt;If even outer index is too large to fit in main memory, yet another level of index can be created, and so on&lt;/li&gt;
  &lt;li&gt;Indices at all levels must be updated on insertion or deletion from the file.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/MultilevelIndex.jpg&quot; alt=&quot;screenshot&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;b-tree-index-files&quot;&gt;B+-Tree Index Files&lt;/h1&gt;

&lt;h2 id=&quot;b-tree-is-a-rooted-tree-satisfying-the-following-properties&quot;&gt;B+-tree is a rooted tree satisfying the following properties:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;All paths from root to leaf are of the same length (balanced)&lt;br /&gt;&lt;br /&gt;
==&amp;gt; Complete Binary Rebalanceing Tree&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Each node that is not a root or a leaf has between [n/2] and n children&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A leaf node has between [(n−1)/2] and n–1 values&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Special cases: &lt;br /&gt;&lt;br /&gt;
  1.If the root is not a leaf, it has at least 2 children.&lt;br /&gt;&lt;br /&gt;
  2.If the root is a leaf (that is, there are no other nodes in the tree), it can have between 0 and (n–1) values.&lt;br /&gt;&lt;br /&gt;
  Disk-base data structure (not main memory)&lt;br /&gt;&lt;br /&gt;
      - Page&lt;br /&gt;&lt;br /&gt;
  Fanout n of a node: the number of pointers out of the node&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/03/dictionary-tolerant-retrival</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/dictionary-tolerant-retrival</guid>
			</item>
		
			<item>
				<title>Intersecting two postings lists / Boolean queries</title>
				<description>&lt;h1 id=&quot;intersecting-two-postings-lists--continue-&quot;&gt;Intersecting two postings lists ( Continue )&lt;/h1&gt;

&lt;p&gt;AND NOT (p1, p2) -&amp;gt; p1 에는 있고 p2 에는 없는것&lt;/p&gt;
&lt;pre&gt;
Intersect AND NOT (p1,p2)
	answer = {}
	while p1 is not null and p2 is not null:
		if docId(p1) &amp;lt; docId(p2):
			add(answer,docId(p1))
			p1 &amp;lt;- next(p1)
		else if docId(p2) &amp;lt; docId(p1):
			p2 &amp;lt;- next(p2)
		else :
			p1 &amp;lt;- next(p1)
			p2 &amp;lt;- next(p2)
	while p1 is not NULL:
		add(answer,docId(p1))
		p1 &amp;lt;- next(p1)
	return answer
&lt;/pre&gt;

&lt;p&gt;OR (p1,p2) -&amp;gt; p1 이나 p2 둘중 아무 곳에다 있는것&lt;/p&gt;
&lt;pre&gt;
Intersect OR (p1,p2)
	answer = {}
	if p1 is not NULL:
	    while p2 is not NULL:
	    	add(answer, p2)
	    	p2 &amp;lt;- next(p2)
	if p2 is not NULL:
	    while p1 not NULL:      
	        add(answer, p1)
	        p1 &amp;lt;- next(p1)
&lt;/pre&gt;
&lt;p&gt;Boolean queries&lt;br /&gt;
============&lt;br /&gt;
Boolean Queries are queries using AND, OR and NOT to join query terms &lt;br /&gt;Perhaps the simplest model to build an IR system on&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Views each document as a &lt;strong&gt;set&lt;/strong&gt; of words&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Is precise: document matches condition or not&lt;br /&gt;&lt;br /&gt;
==&amp;gt; set : word 의 order / frequency 는 고려하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example---westlaw&quot;&gt;Example - WestLaw&lt;/h2&gt;
&lt;pre&gt;
LIMIT! /3 STATUTE ACTION /S FEDERAL /2 TORT /3 CLAIM
blank : or operation
~! : start with prefix ( ex LIMIT 로 시작하는 단어 )
&lt;/pre&gt;
&lt;p&gt;Phrase queries&lt;br /&gt;
============&lt;br /&gt;
Biword indexes&lt;br /&gt;
————&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Index every consecutive pair of terms in the text as a phrase&lt;/li&gt;
  &lt;li&gt;Each of these biwords is now a dictionary term&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#Problem&lt;br /&gt;
Longer phrase queries -&amp;gt; n words ==&amp;gt; (n+1)Combination(2) ==&amp;gt; O(n^2)&lt;br /&gt;&lt;br /&gt;
Index blowup due to bigger dictionary&lt;br /&gt;&lt;br /&gt;
Infeasible for more than biwords, big even for them&lt;br /&gt;&lt;br /&gt;
ex)&lt;br /&gt;
A B C D E -&amp;gt; there is 6 position to stand words&lt;br /&gt;&lt;br /&gt;
So (6)Combination(2) biwords exists&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;positional-indexes&quot;&gt;Positional indexes&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Extract inverted index entries for each distinct term&lt;/li&gt;
  &lt;li&gt;Merge their doc: position lists to enumerate all positions with terms&lt;/li&gt;
  &lt;li&gt;Same general method for proximity searches&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;“to be or not to be” -&amp;gt; “to” “be” “to” “be”&lt;br /&gt;&lt;br /&gt;
Index -&amp;gt; “to” 0 / “be” 1 / “to” 4 / “be” 5&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
1 / 2 과정&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/positionalIndexes.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;3 과정&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/positionalIndexes2.png&quot; alt=&quot;screenshot&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;DocId 가 다르면 포인터를 다음 DocId 로 옮긴다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
Result ==&amp;gt; 429/430 (first to be) , 433/434 (second to be)&lt;/p&gt;

</description>
				<pubDate>Mon, 20 Mar 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/03/intersecting-posting-boolean-queries</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/intersecting-posting-boolean-queries</guid>
			</item>
		
			<item>
				<title>Intersecting two postings lists</title>
				<description>&lt;h1 id=&quot;intersecting-two-postings-lists--continue-&quot;&gt;Intersecting two postings lists ( Continue )&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
For the intersection of two posting lists of lengths x and y, its time complexity is O(x + y)&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
Intersect(p1,p2)
	answer = {}
	while p1 is not null and p2 is not null:
		if docId(p1) == docId(p2):
			add(answer,docId(p1))
			p1 &amp;lt;- next(p1)
			p2 &amp;lt;- next(p2)
		else if docId(p1) &amp;lt; docId(p2):
			p1 &amp;lt;- next(p1)
		else :
			p2 &amp;lt;- next(p2)
	return answer
&lt;/pre&gt;

&lt;h2 id=&quot;completeness&quot;&gt;Completeness&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
Prove that the algorithm INTERSECTION finds the complete list of common docIDs&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
Proof by mathematical induction&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Premise&lt;br /&gt;&lt;br /&gt;
Lists L1 and L2 share a set of common docIDs &amp;lt;d1, d2, .., dn&amp;gt; which are in the increasing order&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prove&lt;br /&gt;&lt;br /&gt;
  - we change the presudo code slightly that initial answer is { d0 }&lt;br /&gt;
  - At the beginning of each Iteration where d(i-1) &amp;lt; docId(p1) &amp;lt; d(i) and d(i-1) &amp;lt; docId(p2) &amp;lt; d(i)&lt;br /&gt;&lt;br /&gt;
-&amp;gt; answer is {d0, d1, d2, … d(i-1)}&lt;br /&gt;&lt;br /&gt;
(Loop Invariant)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Maintenance&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
	if docId(p1) == docId(p2) == d(i):
		answer = {d0, ... , d(i)}
		d(i) &amp;lt; docId(p1) &amp;lt;= d(i+1)
		d(i) &amp;lt; docId(p2) &amp;lt;= d(i+1)
	else :
		d(i-1) &amp;lt; docId(p1) &amp;lt;= d(i)
		d(i-1) &amp;lt; docId(p2) &amp;lt;= d(i)
&lt;/pre&gt;
&lt;p&gt;  =&amp;gt; p1 이나 p2 가 shift 되면 d(i)보다 커질수 있다?&lt;br /&gt;&lt;br /&gt;
  ===&amp;gt;  아니다. Loop Invariant 에서 어긋남&lt;br /&gt;&lt;br /&gt;
  ===&amp;gt; Thus, At the beginning of next Iteration, the loop invariant is still true&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
  4. Temination&lt;br /&gt;&lt;br /&gt;
  For simple proof, assume docId(NULL) = d(Last number) &amp;gt; d(n)&lt;br /&gt;&lt;br /&gt;
  W.L.O.G , Let’s say p1 = NULL . That is d(n) &amp;lt; docId(p1) &amp;lt;= d(L) and d(n) &amp;lt; docId(p2) &amp;lt;= d(L) &lt;br /&gt;&lt;br /&gt;
  By the Loop invariant, answer is {d0, …, d(n)}&lt;/p&gt;
</description>
				<pubDate>Sun, 19 Mar 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/03/intersecting-posting</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/intersecting-posting</guid>
			</item>
		
			<item>
				<title>Inverted Index</title>
				<description>&lt;h1 id=&quot;inverted-index&quot;&gt;Inverted Index&lt;/h1&gt;

&lt;h2 id=&quot;inverted-index-construction&quot;&gt;Inverted Index Construction&lt;/h2&gt;
&lt;pre&gt;
			Document			ex) Friends are Romans
				▼
			Tokenizer			Friends, are, Romans
				▼
			Linguistic Modules		friend, are, roman
				▼
			Indexer				friend -&amp;gt; posting = (2, 4, ...)
							roman -&amp;gt; posting = (13, 16 ...)
&lt;/pre&gt;

&lt;h2 id=&quot;initial-stages-of-text-processing&quot;&gt;Initial Stages of Text Processing&lt;/h2&gt;

&lt;h3 id=&quot;normalization&quot;&gt;Normalization&lt;/h3&gt;
&lt;h5 id=&quot;map-text-and-query-term-to-same-form&quot;&gt;Map text and query term to same form&lt;/h5&gt;
&lt;p&gt;ex) you want U.S.A and USA to match&lt;/p&gt;

&lt;h3 id=&quot;tokenization&quot;&gt;Tokenization&lt;/h3&gt;
&lt;h5 id=&quot;cut-character-sequence-into-word-tokens&quot;&gt;Cut Character sequence into word tokens&lt;/h5&gt;

&lt;h3 id=&quot;stemming-어근&quot;&gt;Stemming (어근)&lt;/h3&gt;
&lt;h5 id=&quot;we-may-wish-different-forms-of-a-root-to-match&quot;&gt;we may wish different forms of a root to match&lt;/h5&gt;
&lt;p&gt;ex) computer, computing, computation .. =&amp;gt; compute&lt;/p&gt;

&lt;h3 id=&quot;stop-words&quot;&gt;Stop words&lt;/h3&gt;
&lt;h5 id=&quot;we-may-omit-very-common-words-or-not&quot;&gt;we may omit very common words (or not)&lt;/h5&gt;
&lt;p&gt;ex) the, a, of, to …&lt;/p&gt;

&lt;h2 id=&quot;indexer-step&quot;&gt;Indexer step&lt;/h2&gt;

&lt;h3 id=&quot;step-1-token-sequence&quot;&gt;Step 1) Token sequence&lt;/h3&gt;
&lt;h4 id=&quot;sequence-of--modified-token-docid--paris&quot;&gt;sequence of ( Modified token, docID ) paris&lt;/h4&gt;

&lt;h3 id=&quot;step-2-sorts&quot;&gt;Step 2) Sorts&lt;/h3&gt;
&lt;h4 id=&quot;sort-by-terms-and-docid&quot;&gt;sort by terms and docID&lt;/h4&gt;

&lt;h3 id=&quot;step-3-dictionary--postings&quot;&gt;Step 3) Dictionary &amp;amp; Postings&lt;/h3&gt;
&lt;h4 id=&quot;--1-multiple-term-entries-in-a-single-document-are-merged&quot;&gt;- 1. Multiple term entries in a single document are merged&lt;/h4&gt;
&lt;h4 id=&quot;--2-split-into-dictionary-and-posting&quot;&gt;- 2. Split into dictionary and posting&lt;/h4&gt;
&lt;h4 id=&quot;--3-document-frequency-information-is-added&quot;&gt;- 3. Document frequency information is added&lt;/h4&gt;
&lt;p&gt;=&amp;gt; Has O(nlogn) time -&amp;gt; using Map Reduce to reduce time&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;p&gt;Doc1 boy deep fire sea&lt;br /&gt;&lt;br /&gt;
Doc2 nation sea deep&lt;br /&gt;&lt;br /&gt;
Doc3 nation apple fire ban&lt;br /&gt;&lt;br /&gt;
Doc4 nine nation boy people&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;step 1. (boy, doc1) (deep, doc1) (fire, doc1) (sea, doc1)
		(nation, doc2) (sea, doc2) (deep, doc2)
		(nation, doc3) (apple, doc3) (fire, doc3) (ban, doc3)
		(nine, doc4) (nation, doc4) (boy, doc4) (people, doc4)

step 2. (apple, doc3)
		(ban, doc3)
		(boy, doc1)
		(boy, doc4)
		(deep, doc1)
		(deep, doc2)
		(fire, doc1)
		(fire, doc3)
		(nation, doc2)
		(nation, doc3)
		(nation, doc4)
		(nine, doc4)
		(sea, doc1)
		(sea, doc2)
		(people, doc4)

step 3. apple : 1 -&amp;gt; doc3
		ban : 1 -&amp;gt; doc3
		boy : 2 -&amp;gt; doc1, doc4
		deep : 2 -&amp;gt; doc1, doc2
		fire : 2 -&amp;gt; doc1, doc3
		nation : 3 -&amp;gt; doc2, doc3, doc4
		nine : 1 -&amp;gt; doc4
		sea : 2 -&amp;gt; doc1, doc2
		people : 1 -&amp;gt; doc4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;query-processing&quot;&gt;Query Processing&lt;/h2&gt;
&lt;h4 id=&quot;step-1-and-operation&quot;&gt;Step 1). AND operation&lt;/h4&gt;
&lt;p&gt;(consider processing the query A AND B)&lt;/p&gt;
&lt;h4 id=&quot;step-2-locate-a-in-dictionary&quot;&gt;Step 2). Locate A in Dictionary&lt;/h4&gt;
&lt;h4 id=&quot;step-3-locate-b-in-dictionary&quot;&gt;Step 3). Locate B in Dictionary&lt;/h4&gt;
&lt;h4 id=&quot;step-4-merge-the-two-posting-and-find-interested-things&quot;&gt;Step 4). Merge the two posting and find interested things&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;‘A’ token Dictionary / ‘B’ token Dictionary -&amp;gt; insert hash table == O(n) time&lt;br /&gt;&lt;br /&gt;
But! hash table 크기가 현실적으로 매우커서 메모리에 상주하게 두고 검색 불가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pointer X ▼&lt;br /&gt;&lt;br /&gt;
‘A’ :  word1 / word2 …&lt;br /&gt;&lt;br /&gt;
pointer Y ▼&lt;br /&gt;&lt;br /&gt;
‘B’ :  word2 / word8 …&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
Two pointer x, y =&amp;gt; 해당 포인터 값이 더 작은게 한칸씩 이동하며 비교&lt;br /&gt;&lt;br /&gt;
포인터 값끼리 비교하며 같은 값이 있는 경우 뽑아냄&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
if A length is A’ and B length is B’ , O(A’+B’) linear time&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;Curial : Each posting must be sorted by DocId&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Mon, 13 Mar 2017 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2017/03/inverted-index</link>
				<guid isPermaLink="true">http://localhost:4000/2017/03/inverted-index</guid>
			</item>
		
	</channel>
</rss>
